package ru.rkapp.methods;

import ru.rkapp.RungeKuttaMethod;
import ru.rkapp.RightCalculator;
import java.util.Arrays;
import org.apache.logging.log4j.LogManager;

/**
 * Реализация неявного метода Эверхарта (Everhart) для численного интегрирования
 * систем обыкновенных дифференциальных уравнений (ОДУ) с переменным порядком
 * (2-32) и автоматическим выбором шага. Поддерживает квадратурные узлы
 * Гаусса-Радо (Radau) для нечетных порядков и Гаусса-Лобатто (Lobatto) для
 * четных порядков.
 *
 * <p>
 * Ключевые особенности:
 * <ul>
 * <li>Адаптивный порядок интегрирования: от 2 до 32</li>
 * <li>Автоматический контроль шага на основе локальной погрешности</li>
 * <li>Механизм плотного вывода (dense output) для интерполяции решения внутри
 * шага</li>
 * <li>Итерационное уточнение решения с контролем сходимости</li>
 * <li>Поддержка обратного интегрирования (отрицательные шаги)</li>
 * </ul>
 *
 * Everhart, E. (1985). "An Efficient Integrator that Uses Gauss-Radau
 * Spacings".
 */
public class Everhart extends RungeKuttaMethod {

    private static final org.apache.logging.log4j.Logger LOG = LogManager.getLogger(Everhart.class);

    /**
     * Максимальный поддерживаемый порядок метода.
     */
    public static final int MAX_ORDER = 32;
    private static final double MIN_ERROR = 1e-15;

    /**
     * Таблица узлов квадратурных формул Гаусса-Радо (для нечётных порядков) и
     * Гаусса-Лобатто (для чётных порядков) на интервале [0, 1].
     * <p>
     * <b>Структура и математические свойства:</b>
     * <ul>
     * <li>Узлы упорядочены по возрастанию порядка метода (от 2 до 32)</li>
     * <li>Для метода порядка p:
     * <ul>
     * <li>Количество узлов: <code>s = p / 2</code> (целочисленное деление)</li>
     * <li><b>Radau</b> (нечётные p): содержит <code>s</code> узлов в (0, 1), не
     * включает 0 и 1, последний узел &lt; 1.0</li>
     * <li><b>Lobatto</b> (чётные p): содержит <code>s</code> узлов, включает
     * 1.0 как последний узел, не включает 0.0</li>
     * </ul>
     * </li>
     * <li>Узлы являются корнями ортогональных полиномов:
     * <ul>
     * <li>Radau: корни <code>P<sub>s-1</sub>(x) + P<sub>s</sub>(x)</code></li>
     * <li>Lobatto: корни <code>P'<sub>s</sub>(x)</code></li>
     * </ul>
     * где <code>P<sub>s</sub>(x)</code> - полином Лежандра степени
     * <code>s</code>
     * </li>
     * <li>Точность интегрирования:
     * <ul>
     * <li>Radau: алгебраический порядок <code>2s</code></li>
     * <li>Lobatto: алгебраический порядок <code>2s-2</code></li>
     * </ul>
     * </li>
     * </ul>
     *
     * <p>
     * <b>Индексация в массиве:</b><br>
     * Начальный индекс для порядка <code>p</code> вычисляется как:<br>
     * <code>spacingIndex = s * (p - s - 1)</code><br>
     * где <code>s = p / 2</code> (целочисленное деление).
     *
     * <p>
     * <b>Источник:</b> Everhart, E. (1985). "An Efficient Integrator that Uses
     * Gauss-Radau Spacings".
     */
    private static final double[] SPACINGS = {
        // Порядок 2 (Lobatto, s=1, точность 0): 
        //   Единственный узел в конце интервала
        1.0,

        // Порядок 3 (Radau, s=1, точность 2): 
        //   Узел Радо II типа
        2.0 / 3.0,

        // Порядок 4 (Lobatto, s=2, точность 2): 
        //   Стандартные узлы Лобатто 4-го порядка
        0.5, 
        1.0,

        // Порядок 5 (Radau, s=2, точность 4): 
        //   Узлы Радо для полинома Лежандра 2-й степени
        (6.0 - Math.sqrt(6.0)) / 10.0,
        (6.0 + Math.sqrt(6.0)) / 10.0,

        // Порядок 6 (Lobatto, s=3, точность 4): 
        //   Узлы Лобатто с симметричным распределением
        (5.0 - Math.sqrt(5.0)) / 10.0,
        (5.0 + Math.sqrt(5.0)) / 10.0,
        1.0,

        // Порядок 7 (Radau, s=3, точность 6): 
        //   Оптимальные узлы Радо 7-го порядка
        0.21234053823915294397475811012400,
        0.59053313555926528913507374793117,
        0.91141204048729605260445385623054,

        // Порядок 8 (Lobatto, s=4, точность 6): 
        //   Узлы Лобатто с включением центральной точки
        (7.0 - Math.sqrt(21.0)) / 14.0,
        0.5,
        (7.0 + Math.sqrt(21.0)) / 14.0,
        1.0,

        // Порядок 9 (Radau, s=4, точность 8): 
        //   Узлы Радо для высокоточного интегрирования
        0.13975986434378055215208708112488,
        0.41640956763108317994330233133708,
        0.72315698636187617231995400231437,
        0.94289580388548231780687880744588,

        // Порядок 10 (Lobatto, s=5, точность 8): 
        //   Симметричные узлы Лобатто с иррациональными коэффициентами
        0.5 - Math.sqrt(147.0 + 42.0 * Math.sqrt(7.0)) / 42.0,
        0.5 - Math.sqrt(147.0 - 42.0 * Math.sqrt(7.0)) / 42.0,
        0.5 + Math.sqrt(147.0 - 42.0 * Math.sqrt(7.0)) / 42.0,
        0.5 + Math.sqrt(147.0 + 42.0 * Math.sqrt(7.0)) / 42.0,
        1.0,

        // Порядок 11 (Radau, s=5, точность 10): 
        //   Узлы Радо для сверхвысокой точности
        0.09853508579882642612349889788775,
        0.30453572664636390548538517627883,
        0.56202518975261385599498747999477,
        0.80198658212639182746420786320470,
        0.96019014294853125765919330990667,

        // Порядок 12 (Lobatto, s=6, точность 10): 
        //   Лобатто с центральным узлом 0.5
        0.5 - Math.sqrt(495.0 + 66.0 * Math.sqrt(15.0)) / 66.0,
        0.5 - Math.sqrt(495.0 - 66.0 * Math.sqrt(15.0)) / 66.0,
        0.5,
        0.5 + Math.sqrt(495.0 - 66.0 * Math.sqrt(15.0)) / 66.0,
        0.5 + Math.sqrt(495.0 + 66.0 * Math.sqrt(15.0)) / 66.0,
        1.0,

        // Порядок 13 (Radau, s=6, точность 12): 
        //   Радо с шестью узлами для интегрирования высокого порядка
        0.07305432868025888514812603418031,
        0.23076613796994549908311663988435,
        0.44132848122844986791860665819448,
        0.66301530971884570090294702791922,
        0.85192140033151570815002314750402,
        0.97068357284021510802794972308684,

        // Порядок 14 (Lobatto, s=7, точность 12): 
        //   Семьюузловая формула Лобатто
        0.06412992574519669233127711938966,
        0.20414990928342884892774463430102,
        0.39535039104876056561567136982732,
        0.60464960895123943438432863017268,
        0.79585009071657115107225536569898,
        0.93587007425480330766872288061033,
        1.00000000000000000000000000000000,

        // Порядок 15 (Radau, s=7, точность 14): 
        //   Радо 15-го порядка - максимум для большинства практических задач
        0.05626256053692214646565219103231,
        0.18024069173689236498757994280918,
        0.35262471711316963737390777017124,
        0.54715362633055538300144855765235,
        0.73421017721541053152321060830661,
        0.88532094683909576809035976293249,
        0.97752061356128750189117450042915,

        // Порядок 16 (Lobatto, s=8, точность 14): 
        //   Восьмиузловая формула с центральной точкой
        0.05012100229426992134382737779083,
        0.16140686024463112327705728645432,
        0.31844126808691092064462396564567,
        0.50000000000000000000000000000000,
        0.68155873191308907935537603435433,
        0.83859313975536887672294271354567,
        0.94987899770573007865617262220917,
        1.00000000000000000000000000000000,

        // Порядок 17 (Radau, s=8, точность 16): 
        //   Радо для сверхточных вычислений
        0.04463395528996985073312102185830,
        0.14436625704214557148521852022821,
        0.28682475714443051894868623974909,
        0.45481331519657335096772777004679,
        0.62806783541672769756914603951737,
        0.78569152060436924164245873241833,
        0.90867639210020604399625854192546,
        0.98222008485263654818679489896232,

        // Порядок 18 (Lobatto, s=9, точность 16): 
        //   Девятиузловая формула Лобатто
        0.04023304591677059308553366958883,
        0.13061306744724746249844691257008,
        0.26103752509477775216941245363437,
        0.41736052116680648768689011702091,
        0.58263947883319351231310988297909,
        0.73896247490522224783058754636563,
        0.86938693255275253750155308742992,
        0.95976695408322940691446633041117,
        1.00000000000000000000000000000000,

        // Порядок 19 (Radau, s=9, точность 18): 
        //   Радо для специализированных вычислений
        0.03625781288320946094116430076808,
        0.11807897878999870019228511199474,
        0.23717698481496038531730669285327,
        0.38188276530470597536077024839650,
        0.53802959891898906511685689131944,
        0.69033242007236218294037953277052,
        0.82388334383700471813682425392743,
        0.92561261029080395536408181404400,
        0.98558759035112345136717325918919,

        // Порядок 20 (Lobatto, s=10, точность 18): 
        //   Десятиузловая формула с центральной точкой
        0.03299928479597043283386293195030,
        0.10775826316842779068879109194577,
        0.21738233650189749676451801526112,
        0.35212093220653030428404424222047,
        0.50000000000000000000000000000000,
        0.64787906779346969571595575777953,
        0.78261766349810250323548198473888,
        0.89224173683157220931120890805423,
        0.96700071520402956716613706804969,
        1.00000000000000000000000000000000,

        // Порядок 21 (Radau, s=10, точность 20): 
        //   Радо для экспертных вычислений
        0.03002903216148649704306435763440,
        0.09828901220985322965120102159023,
        0.19902107896310115486205369838276,
        0.32405553832333489264284949106524,
        0.46326123428433936712690482228811,
        0.60536015311421315703804789492239,
        0.73884032399154375973394834194515,
        0.85288855035692975957240056442018,
        0.93826792812285187447737063280575,
        0.98808238656758440309025441304101,

        // Порядок 22 (Lobatto, s=11, точность 20): 
        //   Одиннадцатиузловая формула
        0.02755036388855888829620993084839,
        0.09036033917799666082567920914154,
        0.18356192348406966116879757277817,
        0.30023452951732553386782510421652,
        0.43172353357253622256796907213015,
        0.56827646642746377743203092786985,
        0.69976547048267446613217489578348,
        0.81643807651593033883120242722183,
        0.90963966082200333917432079085845,
        0.97244963611144111170379006915161,
        1.00000000000000000000000000000000,

        // Порядок 23 (Radau, s=11, точность 22): 
        //   Радо для прецизионных вычислений
        0.02527362039752034975333118646162,
        0.08304161344740514670686537298197,
        0.16917510037718142596943345609434,
        0.27779671510903207443667869219539,
        0.40150272023286081677227928632696,
        0.53186238691041595791688961924225,
        0.65999184208533481176639476610298,
        0.77715939295616214449216854654264,
        0.87538077485555692626470041273609,
        0.94796454887281944741645730422704,
        0.98998171953831959415697527013220,

        // Порядок 24 (Lobatto, s=12, точность 22): 
        //   Двенадцатиузловая формула с центральной точкой
        0.02334507667891804405154726762227,
        0.07682621767406384156703719645062,
        0.15690576545912128696362048021682,
        0.25854508945433189912653138318153,
        0.37535653494688000371566314981289,
        0.50000000000000000000000000000000,
        0.62464346505311999628433685018711,
        0.74145491054566810087346861681847,
        0.84309423454087871303637951978318,
        0.92317378232593615843296280354938,
        0.97665492332108195594845273237772,
        1.00000000000000000000000000000000,

        // Порядок 25 (Radau, s=12, точность 24): 
        //   Радо максимальной точности
        0.02156206316585036090809308308300,
        0.07105789873558898215118984486568,
        0.14544745623506411920978808359438,
        0.24040111047477294625739742595658,
        0.35039934972274500723370827665702,
        0.46904915068718232937106975710318,
        0.58945491879854231751096564944067,
        0.70461911573741977837708316562399,
        0.80784894547014595900894274377139,
        0.89314550911652334236589322956750,
        0.95555353684459227697453320121445,
        0.99146094501157258063133553912216,

        // Порядок 26 (Lobatto, s=13, точность 24): 
        //   Тринадцатиузловая формула
        0.02003247736636954932244991899228,
        0.06609947308482637449988989854586,
        0.13556570045433692970766379973955,
        0.22468029853567647234168864707046,
        0.32863799332864357747804829817916,
        0.44183406555814806617061164513192,
        0.55816593444185193382938835486808,
        0.67136200667135642252195170182084,
        0.77531970146432352765831135292954,
        0.86443429954566307029233620026044,
        0.93390052691517362550011010145413,
        0.97996752263363045067755008100771,
        1.00000000000000000000000000000000,

        // Порядок 27 (Radau, s=13, точность 26): 
        //   Радо для астрономических вычислений
        0.01861036501098785143971937784028,
        0.06147554089926898760236661323470,
        0.12630517869331058063228543286826,
        0.20984297172656251444713666750062,
        0.30789899828039834310295804831233,
        0.41555603597865954449577915218909,
        0.52741561399588227482490535732140,
        0.63786860271776119959131870177268,
        0.74137645929423748341020926717731,
        0.83274898860844226850447752124064,
        0.90740477530099736471710862456138,
        0.96160186126032164962316747513586,
        0.99263534897391067834930850158618,

        // Порядок 28 (Lobatto, s=14, точность 26): 
        //   Четырнадцатиузловая формула с центральной точкой
        0.01737703674808071360207430396519,
        0.05745897788851185058729918425888,
        0.11824015502409239964794076201185,
        0.19687339726507714443823503068163,
        0.28968097264316375953905153063071,
        0.39232302231810288088716027686354,
        0.50000000000000000000000000000000,
        0.60767697768189711911283972313646,
        0.71031902735683624046094846936929,
        0.80312660273492285556176496931837,
        0.88175984497590760035205923798815,
        0.94254102211148814941270081574111,
        0.98262296325191928639792569603480,
        1.00000000000000000000000000000000,

        // Порядок 29 (Radau, s=14, точность 28): 
        //   Радо для гравитационных расчетов
        0.01622476590139976171877199085899,
        0.05369729993972461646659405657527,
        0.11065719118048446030912833905351,
        0.18461026055652535802692578138794,
        0.27232354711073531456397327200967,
        0.36996331162959604211551940586857,
        0.47326213866012696794627305518712,
        0.57770534269242974215959101248190,
        0.67872825601106382559765960258696,
        0.77191572935074200846535590138006,
        0.85319513231878627007633983473920,
        0.91901450031804481560754869226002,
        0.96649859546798685996403607142943,
        0.99358323920718154318917953590549,

        // Порядок 30 (Lobatto, s=15, точность 28): 
        //   Пятнадцатиузловая симметричная формула
        0.01521597686489103352387863081627,
        0.05039973345326395350268586924007,
        0.10399585406909246803445586451842,
        0.17380564855875345526605839017970,
        0.25697028905643119410905460707656,
        0.35008476554961839595082327263885,
        0.44933686323902527607848349747704,
        0.55066313676097472392151650252296,
        0.64991523445038160404917672736115,
        0.74302971094356880589094539292344,
        0.82619435144124654473394160982029,
        0.89600414593090753196554413548157,
        0.94960026654673604649731413075992,
        0.98478402313510896647612136918373,
        1.00000000000000000000000000000000,

        // Порядок 31 (Radau, s=15, точность 30): 
        //   Радо для моделирования орбит
        0.01426945473682577473409936694087,
        0.04729959009416668566195579247573,
        0.09771329932062197336876149533799,
        0.16356903939438987602444091434582,
        0.24233526096865728800292572225971,
        0.33098480497004012346130436094686,
        0.42611083909331411932854614476247,
        0.52405769153676513942741100798415,
        0.62106131135302196189347099085723,
        0.71339391374247294001597395451560,
        0.79750724494989595243178001167977,
        0.87016897444640894402874546190571,
        0.92858704688484115994521609825327,
        0.97051770135205751336835901528200,
        0.99435931102748829024249353342056,

        // Порядок 32 (Lobatto, s=16, точность 30): 
        //   Шестнадцатиузловая формула с центральной точкой
        0.01343391168429084292151024906313,
        0.04456000204221320218809874680113,
        0.09215187438911484644662472338123,
        0.15448550968615764730254032131377,
        0.22930730033494923043813329624797,
        0.31391278321726147904638265963237,
        0.40524401324084130584786849262344,
        0.50000000000000000000000000000000,
        0.59475598675915869415213150737656,
        0.68608721678273852095361734036763,
        0.77069269966505076956186670375203,
        0.84551449031384235269745967868623,
        0.90784812561088515355337527661876,
        0.95543999795778679781190125319886,
        0.98656608831570915707848975093686,
        1.00000000000000000000000000000000
    };

    /**
     * Текущий порядок интегрирования.
     */
    private int order;

    /**
     * Количество уравнений в системе.
     */
    private final int numberOfEquations;

    /**
     * Допустимая погрешность на шаге.
     */
    private double localError = 1e-11;

    /**
     * Максимальное количество итераций на шаге.
     */
    private int maxIterations = 100;

    /**
     * Флаг проверки сходимости.
     */
    private boolean verifyConvergence = true;

    /**
     * Матрица коэффициентов C.
     */
    private double[][] cMatrix;

    /**
     * Матрица коэффициентов D.
     */
    private double[][] dMatrix;

    /**
     * Матрица коэффициентов E.
     */
    private double[][] eMatrix;

    /**
     * Матрица обратных разностей узлов.
     */
    private double[][] dtaus;

    /**
     * Матрица альфа-коэффициентов.
     */
    private double[][] aCoeffs;

    /**
     * Матрица текущих B-коэффициентов.
     */
    private double[][] bCoeffs;

    /**
     * Матрица предыдущих B-коэффициентов.
     */
    private double[][] bPrevCoeffs;

    /**
     * Правые части уравнений в начальной точке.
     */
    private double[] f0;

    /**
     * Начальные условия текущего шага.
     */
    private double[] y0;

    /**
     * Временный буфер для значений Y.
     */
    private double[] yTemp;

    /**
     * Вспомогательный вектор для промежуточных вычислений.
     */
    private double[] pVector;

    /**
     * Решение на k-ой итерации.
     */
    private double[] yk;

    /**
     * Последние вычисленные правые части.
     */
    private double[] lastF;

    /**
     * Время начала текущего шага.
     */
    private double stepBeginTime;

    /**
     * Размер текущего шага интегрирования.
     */
    private double stepSize;

    /**
     * Флаг первого шага интегрирования.
     */
    private boolean isFirstStep = true;

    /**
     * Размер предыдущего шага интегрирования.
     */
    private double previousStepSize = 0.0;

    /**
     * Счетчик выполненных шагов.
     */
    private long stepCount = 0;

    @Override
    public void initialize() {
        resetState();
        calculateStirlingNumbers();
        calculateDTaus();
    }

    /**
     * Конструктор метода Эверхарта.
     *
     * @param calculator Вычислитель правых частей системы ОДУ
     * @param order Начальный порядок метода (2-32)
     * @param numberOfEquations Количество уравнений в системе
     * @throws IllegalArgumentException Если порядок вне диапазона [2,
     * MAX_ORDER]
     */
    public Everhart(RightCalculator calculator, int order, int numberOfEquations) {
        super(calculator);
        if (order < 2 || order > MAX_ORDER) {
            throw new IllegalArgumentException("Порядок метода должен быть от 2 до " + MAX_ORDER);
        }
        this.order = order;
        this.numberOfEquations = numberOfEquations;
        initializeArrays();
        calculateStirlingNumbers(); // Сначала вычисляем матрицы Стирлинга
        calculateDTaus();           // Затем вычисляем обратные разности
    }

    /**
     * Инициализирует внутренние массивы для хранения коэффициентов и
     * промежуточных вычислений. Вызывается автоматически при создании объекта и
     * при изменении порядка метода.
     */
    private void initializeArrays() {
        int matrixSize = MAX_ORDER / 2 + 1;

        cMatrix = new double[matrixSize][matrixSize];
        dMatrix = new double[matrixSize][matrixSize];
        eMatrix = new double[matrixSize][matrixSize];
        dtaus = new double[MAX_ORDER / 2][];
        for (int i = 0; i < MAX_ORDER / 2; i++) {
            dtaus[i] = new double[i];
        }

        aCoeffs = new double[MAX_ORDER / 2][numberOfEquations];
        bCoeffs = new double[MAX_ORDER / 2][numberOfEquations];
        bPrevCoeffs = new double[MAX_ORDER / 2][numberOfEquations];

        f0 = new double[numberOfEquations];
        y0 = new double[numberOfEquations];
        yTemp = new double[numberOfEquations];
        pVector = new double[numberOfEquations];
        yk = new double[numberOfEquations];
        lastF = new double[numberOfEquations];

        resetState();
    }

    /**
     * Сбрасывает внутреннее состояние метода, обнуляя все коэффициенты и
     * промежуточные значения. Вызывается при изменении порядка метода или при
     * явном сбросе состояния.
     */
    private void resetState() {
        for (int i = 0; i < MAX_ORDER / 2; i++) {
            if (aCoeffs[i] != null) {
                Arrays.fill(aCoeffs[i], 0.0);
            }
            if (bCoeffs[i] != null) {
                Arrays.fill(bCoeffs[i], 0.0);
            }
            if (bPrevCoeffs[i] != null) {
                Arrays.fill(bPrevCoeffs[i], 0.0);
            }
        }
        Arrays.fill(f0, 0.0);
        Arrays.fill(y0, 0.0);
        Arrays.fill(yTemp, 0.0);
        Arrays.fill(pVector, 0.0);
        Arrays.fill(yk, 0.0);
        Arrays.fill(lastF, 0.0);

        isFirstStep = true;
        stepCount = 0;
        previousStepSize = 0.0;
        stepBeginTime = 0.0;
    }

    /**
     * Вычисляет матрицы коэффициентов (C, D, E) и матрицу обратных разностей
     * для текущего порядка метода, используя предопределенные узлы SPACINGS.
     *
     * <p>
     * <b>Алгоритм:</b>
     * <ol>
     * <li><b>Инициализация базовых случаев:</b>
     * <pre>
     *     C[i][0] = D[i][0] = 0.0
     *     E[i][0] = 1.0
     *     C[i][i] = D[i][i] = E[i][i] = 1.0
     * </pre>
     * </li>
     *
     * <li><b>Рекуррентное вычисление коэффициентов:</b>
     * <p>
     * Для каждого j ∈ [0, points-1] и i ∈ [j+1, points-1]:
     * <pre>
     *     C[i+1][j+1] = C[i][j] - t<sub>i-1</sub> * C[i][j+1]
     *     D[i+1][j+1] = D[i][j] + t<sub>j</sub> * D[i][j+1]
     *     E[i+1][j+1] = E[i][j] + E[i][j+1]
     * </pre> где t<sub>k</sub> = SPACINGS[spacingIndex + k]
     * </li>
     *
     * <li><b>Нормализация коэффициентов:</b>
     * <p>
     * Для i,j ∈ [1, points]:
     * <pre>
     *     C[j][i] = C[j][i] / (i + 1)
     *     D[i][j] = D[i][j] * (i + 1)
     *     E[i][j] = E[i][j] * (i + 1)
     * </pre>
     * </li>
     *
     * <li><b>Вычисление обратных разностей:</b>
     * <p>
     * Для каждой пары узлов (i,j) где i > j:
     * <pre>
     *     dtaus[i][j] = 1 / (t<sub>i</sub> - t<sub>j</sub>)
     * </pre> где: t<sub>i</sub> = SPACINGS[spacingIndex + i] t<sub>j</sub> =
     * SPACINGS[spacingIndex + j]
     * </li>
     * </ol>
     *
     * <p>
     * <b>Математическое назначение матриц:</b>
     * <ul>
     * <li><b>C</b>: Коэффициенты преобразования для полиномиальной
     * интерполяции</li>
     * <li><b>D</b>: Коэффициенты обратного преобразования</li>
     * <li><b>E</b>: Матрица перехода между шагами интегрирования</li>
     * <li><b>dtaus</b>: Используется в итерационном процессе уточнения
     * решения</li>
     * </ul>
     *
     * <p>
     * <b>Теоретическая основа:</b>
     * <pre>
     * Матрицы C, D, E реализуют преобразования между:
     *   - Коэффициентами полиномов (A, B)
     *   - Значениями производных
     *   - Предсказаниями на смежных шагах
     *
     * Преобразования соответствуют:
     *   A = D · B
     *   B = C · ΔF
     * </pre>
     *
     * <p>
     * <b>Особенности реализации:</b>
     * <ul>
     * <li>Использует предвычисленные узлы из массива SPACINGS</li>
     * <li>Вычисление выполняется за O(points²) операций</li>
     * <li>Требует однократного выполнения при инициализации метода</li>
     * </ul>
     *
     * @implNote Формулы основаны на работе: Everhart E. (1985) "An Efficient
     * Integrator that Uses Gauss-Radau Spacings"
     */
    private void calculateStirlingNumbers() {
        int points = order / 2;
        int spacingIndex = calculateSpacingIndex();

        // Инициализация матриц
        for (int i = 0; i <= points; i++) {
            for (int j = 0; j <= points; j++) {
                if (j == 0) {
                    cMatrix[i][j] = (i == 0) ? 1.0 : 0.0; // c[0,0]=1, остальные 0
                    dMatrix[i][j] = (i == 0) ? 1.0 : 0.0; // d[0,0]=1, остальные 0
                    eMatrix[i][j] = 1.0; // e[i,0]=1
                } else if (i == j) { // Диагональ = 1
                    cMatrix[i][j] = 1.0;
                    dMatrix[i][j] = 1.0;
                    eMatrix[i][j] = 1.0;
                } else { // Остальные элементы 0
                    cMatrix[i][j] = 0.0;
                    dMatrix[i][j] = 0.0;
                    eMatrix[i][j] = 0.0;
                }
            }
        }

        // Вычисление коэффициентов
        for (int j = 0; j < points; j++) {
            for (int i = j + 1; i < points; i++) {
                cMatrix[i + 1][j + 1] = cMatrix[i][j] - SPACINGS[spacingIndex + i - 1] * cMatrix[i][j + 1];
                dMatrix[i + 1][j + 1] = dMatrix[i][j] + SPACINGS[spacingIndex + j] * dMatrix[i][j + 1];
                eMatrix[i + 1][j + 1] = eMatrix[i][j] + eMatrix[i][j + 1];
            }
        }

        // Нормализация
        for (int i = 1; i <= points; i++) {
            for (int j = 1; j <= points; j++) {
                cMatrix[j][i] /= (i + 1);
                dMatrix[i][j] *= (i + 1);
                eMatrix[i][j] *= (i + 1);
            }
        }
    }

    private void calculateDTaus() {
        int points = order / 2;
        int spacingIndex = calculateSpacingIndex();

        // Обратные разности
        for (int i = 0; i < points; i++) {
            for (int j = 0; j < i; j++) {
                double diff = SPACINGS[spacingIndex + i] - SPACINGS[spacingIndex + j];
                dtaus[i][j] = 1.0 / diff;
            }
        }
    }

    /**
     * Вычисляет индекс начала узлов в массиве SPACINGS для текущего порядка.
     *
     * <p>
     * Формула: index = points * (order - points - 1) где points = order / 2
     *
     * @return Индекс первого узла для текущего порядка в SPACINGS
     */
    private int calculateSpacingIndex() {
        int points = order / 2;
        return points * (order - points - 1);
    }

    /**
     * Выполняет один шаг интегрирования методом Эверхарта.
     *
     * <p>
     * <b>Алгоритм:</b>
     * <ol>
     * <li><b>Подготовка коэффициентов:</b>
     * <p>
     * Вычисление коэффициентов:
     * <pre>
     *     R = h / h<sub>prev</sub>  (отношение текущего шага к предыдущему)
     *     Q = 1.0
     * </pre>
     * <p>
     * Обновление коэффициентов B:
     * <pre>
     *     B<sub>s</sub> = Q * (Σ<sub>m=s</sub><sup>n-1</sup> E<sub>m+1,s+1</sub>·B<sub>m</sub><sup>prev</sup>) / (s+2)
     * </pre> где s ∈ [0, n-1], n = order/2
     * </li>
     *
     * <li><b>Преобразование B → A:</b>
     * <pre>
     *     A<sub>s</sub> = Σ<sub>m=s</sub><sup>n-1</sup> D<sub>m+1,s+1</sub>·B<sub>m</sub>
     * </pre>
     * </li>
     *
     * <li><b>Итерационное уточнение:</b>
     * <p>
     * Для каждого узла t<sub>i</sub> (i ∈ [0, n-1]):
     * <ol type="a">
     * <li>Вычисление промежуточного решения:
     * <pre>
     *         Y<sub>temp</sub> = Y₀ + h·τ<sub>i</sub>·[F₀ + Q(τ<sub>i</sub>)]
     * </pre>
     * </li>
     * <li>Расчет правых частей:
     * <pre>
     *         F<sub>i</sub> = f(t₀ + h·τ<sub>i</sub>, Y<sub>temp</sub>)
     * </pre>
     * </li>
     * <li>Обновление коэффициентов:
     * <pre>
     *         ΔF = (F<sub>i</sub> - F₀) / τ<sub>i</sub>
     *         A<sub>j</sub><sup>new</sup> = A<sub>j</sub><sup>old</sup> + dtaus[i][j]·(ΔF - A<sub>j</sub><sup>old</sup>)  для j < i
     *         B<sub>j</sub> = B<sub>j</sub> + C<sub>i+1,j+1</sub>·(A<sub>i</sub><sup>new</sup> - A<sub>i</sub><sup>old</sup>) для j ≤ i
     * </pre>
     * </li>
     * </ol>
     * </li>
     *
     * <li><b>Контроль сходимости:</b>
     * <pre>
     *     max|Y<sub>temp</sub><sup>(k+1)</sup> - Y<sub>temp</sub><sup>(k)</sup>| ≤ ε<sub>local</sub>·(1 + |Y<sub>temp</sub>|)
     * </pre> где k - номер итерации
     * </li>
     *
     * <li><b>Финальное решение:</b>
     * <p>
     * Для Radau-методов (нечетный порядок):
     * <pre>
     *     Y<sub>new</sub> = Y₀ + h·[F₀ + Q(1)]
     * </pre>
     * <p>
     * Для Lobatto-методов (четный порядок):
     * <pre>
     *     Y<sub>new</sub> = Y<sub>temp</sub>(τ=1)
     * </pre>
     * </li>
     * </ol>
     *
     * <p>
     * <b>Математические обозначения:</b>
     * <ul>
     * <li>Y₀, F₀ - начальное состояние и производная при t=t₀</li>
     * <li>τ<sub>i</sub> = SPACINGS[spacingIndex + i] - узлы интегрирования на
     * [0,1]</li>
     * <li>Q(τ) = Σ<sub>j=0</sub><sup>n-1</sup> B<sub>j</sub>τʲ - полиномиальная
     * коррекция</li>
     * <li>n = order/2 - количество узлов</li>
     * </ul>
     *
     * <p>
     * <b>Особенности реализации:</b>
     * <ul>
     * <li>Поддерживает отрицательные шаги (обратное интегрирование)</li>
     * <li>Автоматически определяет тип метода (Radau/Lobatto) по порядку:
     * <pre>
     *     isRadau = (order % 2 == 1)
     * </pre>
     * </li>
     * <li>Хранит историю коэффициентов B для эффективного предсказания</li>
     * <li>Ограничивает максимальное количество итераций (maxIterations)</li>
     * </ul>
     *
     * <p>
     * <b>Критерии остановки:</b>
     * <ul>
     * <li>Успех: достижение сходимости за ≤ maxIterations итераций</li>
     * <li>Ошибка: - Ошибка вычисления правых частей - Превышение maxIterations
     * (только при verifyConvergence=true) - Деление на ноль при вычислении
     * τ</li>
     * </ul>
     *
     * @param t Начальное время шага (t₀)
     * @param y Начальные условия [y₁, y₂, ..., yₙ] (Y₀)
     * @param h Шаг интегрирования (может быть отрицательным)
     * @param yNew Выходной массив для решения в t₀ + h
     * @param parm Дополнительные параметры для правых частей
     *
     * @return true - шаг успешно завершен, false - ошибка интегрирования или
     * расходимость
     *
     * @implNote Сложность алгоритма: O(n²·m·k), где: n - количество узлов, m -
     * количество уравнений, k - количество итераций
     */
    @Override
    public boolean step(double t, double[] y, double h, double[] yNew, Object parm) {
        if (y.length != numberOfEquations) {
            return false;
        }

        if (yNew == null) {
            yNew = new double[numberOfEquations];
        } else if (yNew.length != numberOfEquations) {
            yNew = new double[numberOfEquations];
        }

        if (h == 0.0) {
            System.arraycopy(y, 0, yNew, 0, numberOfEquations);
            return true;
        }

        int spacingIndex = calculateSpacingIndex();
        int numberOfPoints = order / 2;
        boolean isRadau = ((order - 2 * numberOfPoints) == 1);

        double R = (isFirstStep || previousStepSize == 0) ? 1.0 : h / previousStepSize;
        isFirstStep = false;

        if (stepCount < 2) {
            for (int i = 0; i < numberOfPoints; i++) {
                System.arraycopy(bCoeffs[i], 0, bPrevCoeffs[i], 0, numberOfEquations);
            }
        }

        double Q = 1.0;
        for (int s = 0; s < numberOfPoints; s++) {
            Arrays.fill(pVector, 0.0);

            for (int m = s; m < numberOfPoints; m++) {
                double ems = eMatrix[m + 1][s + 1];
                for (int eq = 0; eq < numberOfEquations; eq++) {
                    pVector[eq] += ems * bCoeffs[m][eq];
                }
            }

            Q *= R;

            for (int eq = 0; eq < numberOfEquations; eq++) {
                double oldBL = bPrevCoeffs[s][eq];
                bCoeffs[s][eq] -= oldBL;
                double newBL = Q * pVector[eq] / (s + 2.0);
                bPrevCoeffs[s][eq] = newBL;
                bCoeffs[s][eq] += newBL;
            }
        }

        for (int s = 0; s < numberOfPoints; s++) {
            Arrays.fill(pVector, 0.0);

            for (int m = s; m < numberOfPoints; m++) {
                double dms = dMatrix[m + 1][s + 1];
                for (int eq = 0; eq < numberOfEquations; eq++) {
                    pVector[eq] += dms * bCoeffs[m][eq];
                }
            }
            System.arraycopy(pVector, 0, aCoeffs[s], 0, numberOfEquations);
        }

        if (isRadau || stepCount == 0) {
            System.arraycopy(y, 0, yTemp, 0, numberOfEquations);
            if (!rightCalculator.compute(t, yTemp, f0, parm)) {
                return false;
            }
        } else {
            System.arraycopy(lastF, 0, f0, 0, numberOfEquations);
        }

        boolean converged = false;
        int iteration;
        for (iteration = 1; iteration <= maxIterations; iteration++) {
            for (int i = 0; i < numberOfPoints; i++) {
                double tau = SPACINGS[spacingIndex + i];
                calculateSolution(tau, numberOfPoints, h, y, f0, yTemp);

                if (!rightCalculator.compute(t + h * tau, yTemp, lastF, parm)) {
                    return false;
                }

                for (int eq = 0; eq < numberOfEquations; eq++) {
                    pVector[eq] = (lastF[eq] - f0[eq]) / tau;
                }

                for (int j = 0; j < i; j++) {
                    double dtausij = dtaus[i][j];
                    for (int eq = 0; eq < numberOfEquations; eq++) {
                        pVector[eq] = dtausij * (pVector[eq] - aCoeffs[j][eq]);
                    }
                }

                for (int j = 0; j <= i; j++) {
                    double cij = cMatrix[i + 1][j + 1];
                    for (int eq = 0; eq < numberOfEquations; eq++) {
                        bCoeffs[j][eq] += cij * (pVector[eq] - aCoeffs[i][eq]);
                    }
                }

                System.arraycopy(pVector, 0, aCoeffs[i], 0, numberOfEquations);
            }

            boolean isConverged = true;
            for (int eq = 0; eq < numberOfEquations; eq++) {
                if (Math.abs(yTemp[eq] - yk[eq]) > Math.abs(localError * yTemp[eq])) {
                    isConverged = false;
                    break;
                }
            }

            if (isConverged) {
                LOG.debug("Converged in {} iterations", iteration);
                converged = true;
                break;
            } else if (iteration < maxIterations) {
                System.arraycopy(yTemp, 0, yk, 0, numberOfEquations);
            }
        }

        if (verifyConvergence && !converged) {
            return false;
        }

        if (isRadau) {
            calculateSolution(1.0, numberOfPoints, h, y, f0, yNew);
        } else {
            System.arraycopy(yTemp, 0, yNew, 0, numberOfEquations);
        }

        stepBeginTime = t;
        previousStepSize = h;
        System.arraycopy(y, 0, y0, 0, numberOfEquations);
        stepCount++;

        return true;
    }

    /**
     * Инициализирует первый шаг интегрирования:
     * <ol>
     * <li>Сохраняет начальные условия</li>
     * <li>Вычисляет правые части в начальной точке</li>
     * </ol>
     *
     * @param t Начальное время
     * @param y Начальные значения
     * @param parm Дополнительные параметры
     * @throws RuntimeException Если ошибка вычисления правых частей
     */
    private void initializeFirstStep(double t, double[] y, Object parm) {
        System.arraycopy(y, 0, y0, 0, numberOfEquations);
        if (!rightCalculator.compute(t, y0, f0, parm)) {
            throw new RuntimeException("Ошибка вычисления правых частей системы ДУ");
        }
    }

    /**
     * Выполняет итерационный процесс уточнения решения для одного шага.
     *
     * <p>
     * Для каждого узла интегрирования:
     * <ol>
     * <li>Вычисляет промежуточное решение через плотный вывод</li>
     * <li>Рассчитывает правые части</li>
     * <li>Обновляет коэффициенты A и B</li>
     * </ol>
     *
     * @param t Текущее время
     * @param h Шаг интегрирования
     * @param points Количество узлов (order / 2)
     * @param spacingIndex Индекс узлов в SPACINGS
     * @param isRadau Тип узлов (true: Radau, false: Lobatto)
     * @param parm Параметры правых частей
     * @return true если итерации выполнены успешно, false при ошибке
     */
    private boolean performIterations(double t, double h, int points, int spacingIndex,
            boolean isRadau, Object parm) {
        for (int i = 0; i < points; i++) {
            double tau = SPACINGS[spacingIndex + i];

            calculateSolution(tau, points, h, y0, f0, yTemp);

            if (!rightCalculator.compute(
                    t + h * tau,
                    yTemp,
                    pVector,
                    parm
            )) {
                return false;
            }

            if (!isRadau && i == points - 1) {
                System.arraycopy(pVector, 0, lastF, 0, numberOfEquations);
            }

            for (int eq = 0; eq < numberOfEquations; eq++) {
                double deltaF = pVector[eq] - f0[eq];
                pVector[eq] = deltaF / tau;
            }

            for (int j = 0; j < i; j++) {
                for (int eq = 0; eq < numberOfEquations; eq++) {
                    pVector[eq] = dtaus[i][j] * (pVector[eq] - aCoeffs[j][eq]);
                }
            }

            for (int eq = 0; eq < numberOfEquations; eq++) {
                double delta = pVector[eq] - aCoeffs[i][eq];
                for (int j = 0; j <= i; j++) {
                    double cij = cMatrix[i + 1][j + 1];
                    bCoeffs[j][eq] += cij * delta;
                }
            }

            for (int eq = 0; eq < numberOfEquations; eq++) {
                aCoeffs[i][eq] = pVector[eq];
            }
        }
        return true;
    }

    /**
     * Вычисляет решение системы обыкновенных дифференциальных уравнений (ОДУ) в
     * произвольной точке внутри текущего шага интегрирования методом
     * полиномиальной интерполяции (плотный вывод).
     *
     * <p>
     * <b>Математическая формула:</b>
     * <pre>
     * Y(τ) = Y₀ + h·τ·[F₀ + Q(τ)]
     * где:
     *   Q(τ) = Σ (Bⱼ·τʲ) для j = 0..n-1
     * </pre>
     *
     * <p>
     * <b>Обозначения:</b>
     * <ul>
     * <li>τ = (t - t₀)/h ∈ [0, 1] - безразмерное время</li>
     * <li>Bⱼ - предвычисленные коэффициенты полинома</li>
     * <li>n = {@code points} - количество узлов интегрирования</li>
     * <li>h - шаг интегрирования</li>
     * <li>Y₀ - начальное состояние при τ=0</li>
     * <li>F₀ - производная в начале шага (при τ=0)</li>
     * </ul>
     *
     * <p>
     * <b>Реализация:</b>
     * <ol>
     * <li>Использует схему Горнера для эффективного вычисления полинома
     * Q(τ)</li>
     * <li>Обеспечивает точность интерполяции, соответствующую порядку
     * метода</li>
     * <li>Гарантирует гладкость решения при соблюдении корректности
     * коэффициентов</li>
     * </ol>
     *
     * <p>
     * <b>Особенности:</b>
     * <ul>
     * <li>При τ=0 возвращает Y₀ (проверочное условие)</li>
     * <li>При τ=1 возвращает решение на конце шага</li>
     * <li>Требует предварительного вычисления коэффициентов Bⱼ в процессе
     * интегрирования</li>
     * </ul>
     *
     * @param tau Безразмерное время в интервале [0, 1]
     * @param points Количество узлов интегрирования (n = порядок метода / 2)
     * @param h Текущий шаг интегрирования (может быть положительным или
     * отрицательным)
     * @param y Начальное состояние вектора решения на шаге [y₀, y₁, ...] (при
     * τ=0)
     * @param f0 Производные в начале шага [f₀, f₁, ...] (правые части ОДУ при
     * τ=0)
     * @param result Выходной массив для записи результата (должен иметь длину
     * равную y.length)
     *
     * @throws IllegalArgumentException если параметры не соответствуют
     * требованиям: - tau ∉ [0, 1] - h = 0 - Несовпадение длин массивов y, f0,
     * result - points < 1
     */
    private void calculateSolution(double tau, int points, double h,
            double[] y, double[] f0, double[] result) {
        Arrays.fill(pVector, 0.0);
        for (int j = points - 1; j >= 0; j--) {
            for (int eq = 0; eq < numberOfEquations; eq++) {
                pVector[eq] = tau * (bCoeffs[j][eq] + pVector[eq]);
            }
        }
        for (int eq = 0; eq < numberOfEquations; eq++) {
            result[eq] = y[eq] + h * tau * (f0[eq] + pVector[eq]);
        }
    }

    /**
     * Вычисляет решение системы ОДУ в произвольной точке внутри последнего шага
     * интегрирования методом полиномиальной интерполяции (плотный вывод).
     *
     * <p>
     * Математическая основа:
     * <pre>
     * Y(τ) = Y₀ + h·τ·F₀ + h·Σ Bⱼ·τ^{j+1}
     * где:
     *   τ = (t - t₀)/h ∈ [0,1] - безразмерное время
     *   Bⱼ - коэффициенты полинома, вычисленные на шаге
     * </pre>
     *
     * @param t Время для интерполяции (t ∈ [t₀, t₀+h])
     * @param y Массив для записи интерполированного решения
     * @return true если интерполяция выполнена успешно, false при ошибке
     */
    @Override
    public boolean interpolate(double t, double[] y) {

        if (isFirstStep || previousStepSize == 0) {
            return false;
        }

//        if (t < stepBeginTime || t > stepBeginTime + stepSize) {
//            return false;
//        }

        double tau = (t - stepBeginTime) / previousStepSize;

        int points = order / 2;

//        if (tau < 0 || tau > 1) {
//            return false;
//        }

        calculateSolution(tau, points, previousStepSize, y0, f0, y);
        return true;
    }

    /**
     * Проверяет сходимость итерационного процесса по критерию: |Yₖ⁺¹ - Yₖ| ≤
     * localError * (|Yₖ⁺¹|)
     *
     * @return true если достигнута заданная точность для всех уравнений
     */
    private boolean checkConvergence() {
        for (int eq = 0; eq < numberOfEquations; eq++) {
            double error = Math.abs(yTemp[eq] - yk[eq]);
            //double tolerance = localError * (Math.abs(yTemp[eq]) + 1e-15);
            double tolerance = localError * Math.abs(yTemp[eq]);
            if (error > tolerance) {
                return false;
            }
        }
        return true;
    }

    // Геттеры и сеттеры 
    /**
     * Установка порядка метода.
     *
     * @param order Новый порядок (2-32)
     * @throws IllegalArgumentException При недопустимом порядке
     */
    public void setOrder(int order) {
        if (order < 2 || order > MAX_ORDER) {
            throw new IllegalArgumentException("Недопустимый порядок метода: " + order);
        }
        this.order = order;
        initialize();
        initializeArrays();
        calculateStirlingNumbers(); // Сначала вычисляем матрицы Стирлинга
        calculateDTaus();           // Затем вычисляем обратные разности    
    }

    /**
     * Полностью сбрасывает состояние метода:
     * <ul>
     * <li>Обнуляет все коэффициенты</li>
     * <li>Сбрасывает счетчик шагов</li>
     * <li>Перевычисляет матрицы коэффициентов</li>
     * </ul>
     */
    public void reset() {
        isFirstStep = true;
        stepCount = 0;
        resetState();
        calculateStirlingNumbers(); // Сначала вычисляем матрицы Стирлинга
        calculateDTaus();           // Затем вычисляем обратные разности
    }

    /**
     * Устанавливает допустимую локальную погрешность.
     *
     * @param localError Желаемая погрешность (≥1e-15)
     */
    public void setLocalError(double localError) {
        this.localError = Math.max(localError, MIN_ERROR);
    }

    /**
     * Устанавливает максимальное количество итераций на шаг.
     *
     * @param maxIterations Минимальное значение: 1
     */
    public void setMaxIterations(int maxIterations) {
        this.maxIterations = Math.max(maxIterations, 1);
    }

    /**
     * Включает/выключает проверку сходимости итераций.
     *
     * @param verifyConvergence true - прерывать шаг при расходимости, false -
     * игнорировать расходимость
     */
    public void setVerifyConvergence(boolean verifyConvergence) {
        this.verifyConvergence = verifyConvergence;
    }

    /**
     * Проверяет, поддерживает ли метод плотный вывод (интерполяцию решения
     * внутри шага).
     *
     * @return true если метод поддерживает интерполяцию, иначе false
     */
    @Override
    public boolean supportsInterpolation() {
        return true;
    }

}
